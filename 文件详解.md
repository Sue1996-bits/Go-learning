### db/watermark_repository.go
仓库逻辑:
记录某个用户对某张图片进行水印处理的操作记录--水印操作日志表（WatermarkLog）
```
type WatermarkLog struct {
	ID           uint      `gorm:"primaryKey"`
	UserID       string
	ImageID      string
	WatermarkID  string
	CreatedAt    time.Time
}
```
作用：

建立水印追溯日志：

创建一个新的数据库模型 WatermarkLog。

每当成功生成一张带水印的图片时，必须在该表中记录一条日志，包含 UserID, ImageID, Watermark (水印ID) 和 Timestamp。这是未来溯源的法律依据。

### db/image_repository.go

存储加密后的图片数据（[]byte）

封装数据库操作逻辑:Create+GetByID

### db/migration.go 

数据库迁移脚本：

1. MigrateWatermarkLog(db *gorm.DB) 的作用：对watermark_logs 表创建，检查，添加
   
2. CreateIndexes(db *gorm.DB) 的作用：
   使用原生的 SQL 语句 (db.Exec) 来创建两个非常重要的、GORM 无法自动生成的高级索引。(user_id, image_id)+降序索引（日志查询几乎总是按时间倒序排列）

### services/cache_service.go
引入高性能缓存：

水印处理是计算密集型操作。为避免重复劳动，需引入缓存机制。

使用内存缓存（如 go-cache）即可。

缓存键（Key）应由 userID 和 imageID 组合而成。

缓存值（Value）是已处理完成并编码好的图片字节流。

### services/verification_service.go

接收一个来源未知的、可能带有水印的图片，对其进行分析，并验证其中是否包含某个特定的信息。

输入：- 来源未知的、可能被篡改的图片<br>- 一个expectedWatermarkID


输出：返回一个 bool 值（是否匹配）。

依赖：只需要 LSBProcessor

通常是一个低频的、管理性质的、用于取证或调试的后台操作`有更严格权限控制的独立API端点上，与普通用户的功能分离开。`

### controllers/verification_controller.go

1.HandleVerify 方法中详尽的错误处理和输入验证：

检查 expectedID: 强制要求请求中必须带有 id 这个查询参数。如果缺失，直接返回 400 Bad Request，并给出明确的错误信息。

检查 file: 强制要求请求体必须是 multipart/form-data 格式，并且包含一个名为 image 的文件部分。如果缺失，同样返回 400 Bad Request。

使用：
使用 Postman 或 curl 发送请求：

方法: POST

URL: http://localhost:8080/api/v1/admin/verify/lsb?id=your_expected_watermark_id

认证: 如果路由受保护，需要提供 Authorization: Bearer <token> 头。

Body: 选择 form-data，创建一个键为 image，类型为 File，然后选择一张可能带有水印的图片文件。
### // middleware/auth.go

基于 JWT 的身份认证中间件--用来保护需要登录才能访问的 API 路由。

检查客户端请求的 Authorization 头部是否带了 Bearer Token。

验证这个 JWT Token 是否有效（签名、过期等）。

如果验证通过，把用户信息（user_id、username）放到 Gin 的 Context 中，方便后续处理。

如果失败，直接返回 HTTP 401（Unauthorized），并终止请求。

```
auth := middleware.NewAuthMiddleware("my_secret_key")

r := gin.Default()

// 保护的路由组
authGroup := r.Group("/api", auth.RequireAuth())
{
	authGroup.GET("/user/profile", getUserProfile)
}
```
### // config/config.go 

高度结构化的配置管理--让整个项目的运行参数（端口、数据库、JWT 密钥、缓存时间、日志格式等）都能统一管理

ServerConfig → HTTP 服务端口、读写超时等。

DatabaseConfig → 数据库类型（SQLite / Postgres）、连接池参数、路径等。

JWTConfig → JWT 密钥、Token 有效期、签发者等。

CacheConfig → 缓存过期时间、清理周期。

LogConfig → 日志级别、格式。

SecretManager → 密钥管理接口（目前内存版，后续可接 KMS）。
```
cfg, err := config.Load()
if err != nil {
	log.Fatal(err)
}
fmt.Println("Server running on port", cfg.Server.Port)

```
