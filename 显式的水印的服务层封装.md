controllers/dewatermark.go

将它封装成一个独立的服务--AddWatermark 函数是一个只关心图像处理的逻辑--使用这个服务来添加明文水印。

### 定义服务接口和实现 (services/visible_watermark_service.go)
// AddTextWatermark 是接口方法的具体实现，包含了原始函数的逻辑

### 在 main.go 中初始化并注入服务
```
func main() {
    // ... 配置 ...
    fontPath := "fonts/font.ttf" // 假设字体文件在项目中的这个路径

    // ... 数据库和其它服务初始化 ...

    // --- 初始化 VisibleWatermarkService ---
    visibleWatermarkSvc := services.NewVisibleWatermarkService(fontPath)

    // --- 将它注入到需要它的控制器中 ---
    // 假设我们有一个专门处理这类请求的控制器
    // legacyController := controllers.NewLegacyController(visibleWatermarkSvc, ...)
    // 或者，如果 ImageController 也需要这个功能，就注入给它
    imageController := controllers.NewImageController(
        // ... 其他依赖 ...
        visibleWatermarkSvc,
    )
    
    // --- 路由 ---
    // 你可以创建一个新的路由来使用这个服务
    // apiV1.POST("/images/:image_id/add-text", imageController.AddTextWatermarkHandler)
}
```

原来：
```
func main() {
    // ... 配置和数据库初始化 ...

    // --- Repositories ---
    encryptedImageRepo := db.NewEncryptedImageRepository(database)
	watermarkLogRepo := db.NewWatermarkRepository(database)
    
    // --- Services (按依赖顺序初始化) ---
    // 纯粹的、无依赖的 service
    idGen := services.NewWatermarkIDGenerator(serverSecret)
	lsbProc := services.NewLSBWatermarkProcessor("blue")

    // 依赖 repo 或其他 service 的
    cryptoSvc, _ := services.NewCryptoService(aesKey)
    imageSvc := services.NewImageService(encryptedImageRepo, cryptoSvc)
    watermarkSvc := services.NewWatermarkService(idGen, lsbProc)
    logSvc := services.NewLogService(watermarkLogRepo)
    
    // 缓存服务
    cacheSvc := services.NewMemoryCache(5*time.Minute, 10*time.Minute)
    
    // --- Controller (注入所有需要的服务) ---
    imageController := controllers.NewImageController(
        cacheSvc,
        imageSvc,
        watermarkSvc,
        logSvc,
    )

    // --- 路由 ---
    // ...
    apiV1.GET("/images/:image_id/watermarked", imageController.GetWatermarkedImage)
    // ...
}
```

集合为路由组：

```
// ... 初始化所有服务 ...

imageController := controllers.NewImageController(...)

apiV1 := r.Group("/api/v1")
{
    // LSB 隐式水印的路由
    apiV1.GET("/images/:image_id/lsb-watermarked", imageController.GetLsbWatermarkedImage)
    
    // 明文显式水印的路由
    apiV1.GET("/images/:image_id/visible-watermark", imageController.AddVisibleWatermark)
}
```

### 控制器
逻辑冲突：一个请求过来，控制器该决定是加 LSB 水印还是明文水印？

解决：而是在 API 路由层面 就把不同的业务需求分开。这让每个处理函数的职责都非常清晰。

对 ImageController进行扩展，让它同时具备处理这两种业务的能力，并通过不同的路由来调用。

```
package controllers

import (
	"bytes"
	"image"
	"image/png"
	"net/http"
	"time"
	"your-project/services"
	"github.com/gin-gonic/gin"
)

// ImageController 现在是全能的，包含了所有需要的服务
type ImageController struct {
	cache                   services.CacheService
	imageService            services.ImageService
	lsbWatermarkService     services.WatermarkService // 之前叫 WatermarkService
	visibleWatermarkService services.VisibleWatermarkService // 新增
	logService              services.LogService
}

// NewImageController 的构造函数也需要更新
func NewImageController(
	cache services.CacheService,
	imgSvc services.ImageService,
	lsbWmSvc services.WatermarkService,
	visWmSvc services.VisibleWatermarkService, // 新增
	logSvc services.LogService,
) *ImageController {
	return &ImageController{
		cache:                   cache,
		imageService:            imgSvc,
		lsbWatermarkService:     lsbWmSvc,
		visibleWatermarkService: visWmSvc,
		logService:              logSvc,
	}
}

// GetLsbWatermarkedImage 处理【隐式 LSB 水印】的请求 (之前的 GetWatermarkedImage)
func (ctrl *ImageController) GetLsbWatermarkedImage(c *gin.Context) {
    // ... 我们之前实现的完整的、带缓存的 LSB 水印流程 ...
    // ... 完全不变 ...
}

// AddVisibleWatermark 处理【显式明文水印】的请求
func (ctrl *ImageController) AddVisibleWatermark(c *gin.Context) {
	imageID := c.Param("image_id")
	watermarkText := c.Query("text")
	if watermarkText == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "query parameter 'text' is required"})
		return
	}
    
	// 1. 获取解密后的原始图片数据 (复用 ImageService)
	// 注意：这个业务通常不需要缓存，因为每次的文字都可能不同。
	// 如果文字是固定的，也可以为其设计一套独立的缓存逻辑。
	decryptedData, contentType, err := ctrl.imageService.GetDecryptedImageData(imageID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get image data: " + err.Error()})
		return
	}

	// 2. 解码图片
	img, _, err := image.Decode(bytes.NewReader(decryptedData))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to decode image: " + err.Error()})
		return
	}

	// 3. 调用 VisibleWatermarkService 添加明文水印
	finalImage, err := ctrl.visibleWatermarkService.AddTextWatermark(img, watermarkText)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to add visible watermark: " + err.Error()})
		return
	}

	// 4. 编码并返回结果
	var buf bytes.Buffer
	// 这里可以根据原始 contentType 决定编码格式，为简单起见，我们用 PNG--统一返回png
	if err := png.Encode(&buf, finalImage); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to encode final image: " + err.Error()})
		return
	}

	c.Header("Content-Type", "image/png")
	c.Data(http.StatusOK, "image/png", buf.Bytes())
}
```



总结:
1.AddWatermark 函数：封装成了一个独立的、符合单一职责原则的 VisibleWatermarkService。

2.解耦了硬编码的配置（如字体路径、边距等），使其更具灵活性。

3.融入了现有的依赖注入和分层架构中。

因为：这两种水印技术在实现上是互不兼容的，不能在同一张图片上叠加使用。

so：系统应该将这两种功能：LSB 水印 / 明文水印 作为互斥的选项提供给用户。


架构上: 采用我们上面设计的“融合控制器 + 独立API端点”的方案。ImageController 同时管理 LSBWatermarkService 和 VisibleWatermarkService。
业务上: 清晰地向用户或前端表明，对于一张原始图片，你可以选择获取：
A) 一个带有用于追踪的、不可见的 LSB 水印的版本 (调用 /.../lsb-watermarked)。
B) 一个带有指定的、可见的文字水印的版本 (调用 /.../visible-watermark?text=...)。

后续：加入频域DCT水印 (变换域，不可见水印)

分离服务: 你可以创建一个 DCTWatermarkService，其内部实现DCT变换和嵌入逻辑。

分离API: 在控制器中，提供独立的API端点来调用这个服务。
GET /api/v1/images/:id/dct-watermarked (获取带DCT水印的版本)
GET /api/v1/images/:id/visible-watermark?text=... (获取带明文水印的版本)

明确产品定位: 向用户或产品设计者阐明，这两种水印是为了不同的目的而存在的：
DCT水印: 用于版权保护、溯源追踪，特点是不可见、稳健。
明文水印: 用于品牌宣传、防止截图盗用，特点是可见、威慑。
它们是解决不同问题的两种工具，不应混在一起使用。

如若：比如在显示带DCT水印的图片时，在前端用HTML/CSS覆盖一个半透明的用户名作为威慑，而不是将文字“烧录”进图片本身。
