使用GORM和sqlite进行数据库存储管理 

1.即使用GROM构建结构体：
```
// 模型（Models）与数据库中的数据表进行映射
type FileRecord struct {
	gorm.Model              // 内置一个
	OriginalFilename string // 原始文件名
	EncryptedBase64  string // 加密后的文件内容
}
```
2.然后在包db中定义数据库的初始化操作
```
var DB *gorm.DB

func InitDatabase() {
	var err error
	// gorm.Open 函数来打开一个 SQLite 数据库文件,并传入一个 gorm.Config 结构体来配置一些选项。
	DB, err = gorm.Open(sqlite.Open("photo.db"), &gorm.Config{}) //!!!注意这里不是:= 是= 即赋值而非新建！！！
	if err != nil {
		log.Fatal("数据库连接失败:", err)
	}
	// 自动建表:db.AutoMigrate 方法来根据结构体定义自动创建数据表。
	if err := DB.AutoMigrate(&models.FileRecord{}); err != nil {
		log.Fatal("自动迁移失败:", err)
	}
	log.Println("✅ 数据库初始化完成")
}
```
3.在controllers/encrpt.go中对base64编码后的文件记录在结构体中，并存储在数据库中
```
record := models.FileRecord{
		OriginalFilename: imageName,
		EncryptedBase64:  encoded,
	}

	// 使用DB.Create 存储文件名和密文
	if err := db.DB.Create(&record).Error; err != nil {
		ctx.JSON(500, gin.H{"error": "保存到数据库失败"})
		return
	}
```
4.注意在main.go中先初始化数据库实例，再注册路由器
```
func main() {

	db.InitDatabase() //初始化链接要在注册路由器之前
	ginServer := gin.Default()
  ...
}
```

review：
go中在函数内部对调用的参数的修改 不会影响原始变量，因为接受到的是拷贝：
```
func changeValue(x int) {
	x = 100
}

func main() {
	a := 10
	changeValue(a)
	fmt.Println(a) // 输出还是 10，不是 100
}
```
传入a的拷贝，不会改变a的本身。
如果想要改变，即传入a的指针：&a  （读取a的地址）
```
func changeValue(x *int) {   //x = 指向 int 类型值的指针，值为一个地址。 
	*x = 100      //*x “解引用” 或 “取值” 操作，获取指针x所指向的内存地址中存放的值。前提 是x必须为一个地址。   
}

func main() {
	a := 10
	changeValue(&a)       // 传入a的地址, &a “取地址” 操作,获取变量a在内存中的地址。
	fmt.Println(a) // 输出 100，✅ 成功修改原始值
}
```
&a *a 互为逆运算


注意：：=赋值必须左边有新的变量才行，任一新都行。

问题：这里用static静态方法直接读取图片不够完成业务需求，需要动态加密读取。
希望请求里面不是直接访问这个图片，用head用法





