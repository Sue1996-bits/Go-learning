1.上传阶段:
用户上传图片。
服务器在内存中对图片进行 AES 加密。
将 加密后 的数据存入数据库。数据库中永远只有密文。
2.水印处理/下载阶段:
控制器接收请求，比如 GET /image/:image_id/watermarked。
服务层通过 image_id 从数据库中取出 加密数据。
在内存中对数据进行 AES 解密，得到临时的明文图片数据。
在这份临时的明文数据上，执行 LSB 水印嵌入。
将加好 LSB 水印的图片（现在又是明文了）编码成 image/jpeg 或 image/png 格式。
将最终的图片二进制流直接返回给用户，不进行任何再次存储。

### 即时处理（On-the-fly）模型。

步骤一：设计加密图片模型和仓库

1.models/encrypted_image.go：模型层（实体定义）

作用：定义数据结构 + GORM 标签，供 GORM 使用。--与数据库中 encrypted_images 表对应。

不负责查询、不负责业务逻辑，仅代表结构体定义。

2.db/image_repository.go：数据库仓库层

封装数据库操作逻辑，如 CRUD（Create / Read / Update / Delete）。

只做数据库操作，不做密码学、也不处理 HTTP 请求。

3.services/crypto_service.go：业务逻辑层

作用：处理加密/解密业务逻辑，协调 Repository 和其他工具库。

聚合业务流程（比如：读取 → 解密 → 返回）。

调用 utils 实现加解密逻辑。

调用 repo 进行数据存取。


### page 2：go-cache 选择
缓存的是“最终结果”，而非“中间状态”。是一个黑盒。

位于业务逻辑的“最外层”： 
·缓存检查是控制器接收到请求后做的第一件事。
·如果缓存命中，整个复杂的业务逻辑（数据库查询、解密、加水印）都会被完全跳过——避免重复的昂贵计算。

与“不存储明文”原则的兼容性：
·数据库是永久性、结构化的存储，是我们的核心资产仓库。
而缓存是临时性、易失性的存储，它的目的是性能优化，我们预期其中的数据随时可能因为过期或内存压力而消失。
·风险可控：
生命周期短： 我们为缓存设置了较短的TTL（Time-To-Live，eg：5分钟）。
·非持久化： 使用go-cache，缓存存在于进程内存中。服务重启，缓存即清空，符合“用后即焚”的大原则。
