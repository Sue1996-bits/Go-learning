1.上传阶段:
用户上传图片。
服务器在内存中对图片进行 AES 加密。
将 加密后 的数据存入数据库。数据库中永远只有密文。
2.水印处理/下载阶段:
控制器接收请求，比如 GET /image/:image_id/watermarked。
服务层通过 image_id 从数据库中取出 加密数据。
在内存中对数据进行 AES 解密，得到临时的明文图片数据。
在这份临时的明文数据上，执行 LSB 水印嵌入。
将加好 LSB 水印的图片（现在又是明文了）编码成 image/jpeg 或 image/png 格式。
将最终的图片二进制流直接返回给用户，不进行任何再次存储。

### 即时处理（On-the-fly）模型。

步骤一：设计加密图片模型和仓库

1.models/encrypted_image.go：模型层（实体定义）

作用：定义数据结构 + GORM 标签，供 GORM 使用。--与数据库中 encrypted_images 表对应。

不负责查询、不负责业务逻辑，仅代表结构体定义。

2.db/image_repository.go：数据库仓库层

封装数据库操作逻辑，如 CRUD（Create / Read / Update / Delete）。

只做数据库操作，不做密码学、也不处理 HTTP 请求。

3.services/crypto_service.go：业务逻辑层

作用：处理加密/解密业务逻辑，协调 Repository 和其他工具库。

聚合业务流程（比如：读取 → 解密 → 返回）。

调用 utils 实现加解密逻辑。

调用 repo 进行数据存取。


### page 2：go-cache 选择
缓存的是“最终结果”，而非“中间状态”。是一个黑盒。

位于业务逻辑的“最外层”： 
·缓存检查是控制器接收到请求后做的第一件事。
·如果缓存命中，整个复杂的业务逻辑（数据库查询、解密、加水印）都会被完全跳过——避免重复的昂贵计算。

与“不存储明文”原则的兼容性：
·数据库是永久性、结构化的存储，是我们的核心资产仓库。
而缓存是临时性、易失性的存储，它的目的是性能优化，我们预期其中的数据随时可能因为过期或内存压力而消失。
·风险可控：
生命周期短： 我们为缓存设置了较短的TTL（Time-To-Live，eg：5分钟）。
·非持久化： 使用go-cache，缓存存在于进程内存中。服务重启，缓存即清空，符合“用后即焚”的大原则。

### 基于时间分片 (Time Sharding) 的缓存策略

我们将时间戳“量化”或“取整”到一个固定的时间间隔。在同一个5分钟内，所有请求都使用相同的时间戳，从而生成相同的 LSB 水印和相同的缓存键，使得缓存能够命中。过了这个5分钟，时间戳更新，缓存自然失效，系统会生成新的带水印的图片并缓存起来。

**工作流程**:
1.  用户 `user-A` 请求 `image-123`。
2.  获取当前时间，并将其**向下取整**到最近的5分钟。例如，`10:03:45` -> `10:00:00`。
3.  生成缓存键，例如 `watermark:user-A:image-123:1678888800` (10:00:00 对应的时间戳)。
4.  **检查缓存**：
    *   **缓存未命中**:
        *   解密图片。
        *   使用 `user-A`, `image-123` 和 **`10:00:00` 的时间戳**生成 LSB 水印。
        *   嵌入水印。
        *   将这个**带 LSB 水印的明文图片**存入缓存，键为 `watermark:user-A:image-123:1678888800`，TTL 设置为5分钟。
        *   返回图片。
    *   **缓存命中**:
        *   直接从缓存中取出**带 LSB 水印的明文图片**并返回。

**依赖注入**
```
func NewWatermarkService(
	serverSecret string,
	cacheService CacheService,
	watermarkRepo db.WatermarkRepository,
	imageRepo db.EncryptedImageRepository,
	cryptoSvc CryptoService,
) WatermarkService {
	return &watermarkServiceImpl{
		// 下面3个是【内部创建】的
		idGenerator:   NewWatermarkIDGenerator(serverSecret),
		lsbProcessor:  NewLSBWatermarkProcessor("blue"),
		cacheKeyGen:   NewCacheKeyGenerator("watermark"),
		
		// 下面4个是【外部注入】的  对应上方的参数导入
		cacheService:  cacheService,
		watermarkRepo: watermarkRepo,
		imageRepo:     imageRepo,
		cryptoService: cryptoSvc,
	}
}
```

v1
```
func (s *watermarkServiceImpl) ProcessWatermarkedImage(userID, imageID string, imgData []byte) ([]byte, *models.WatermarkLog, error) {
	// 1. 检查缓存
	cacheKey := s.cacheKeyGen.WatermarkKey(userID, imageID)
	if cachedData, found := s.cacheService.Get(cacheKey); found {
		// 从数据库获取日志记录
		if log, err := s.watermarkRepo.GetByUserAndImage(userID, imageID); err == nil {
			return cachedData, log, nil
		}
	}

	// 2. 生成水印ID
	timestamp := time.Now().Unix()
	watermarkID, err := s.GenerateWatermarkID(userID, imageID, timestamp)
	if err != nil {
		return nil, nil, err
	}

	// 3. 解码图像
	img, format, err := image.Decode(bytes.NewReader(imgData))
	if err != nil {
		return nil, nil, err
	}

	// 4. 嵌入水印
	watermarkedImg, err := s.EmbedLSBWatermark(img, watermarkID)
	if err != nil {
		return nil, nil, err
	}

	// 5. 编码图像
	var buf bytes.Buffer
	switch format {
	case "jpeg":
		err = jpeg.Encode(&buf, watermarkedImg, &jpeg.Options{Quality: 95})
	case "png":
		err = png.Encode(&buf, watermarkedImg)
	default:
		err = errors.New("unsupported image format")
	}

	if err != nil {
		return nil, nil, err
	}

	watermarkedData := buf.Bytes()

	// 6. 写入缓存
	s.cacheService.Set(cacheKey, watermarkedData, time.Hour)

	// 7. 记录日志
	log := &models.WatermarkLog{
		UserID:      userID,
		ImageID:     imageID,
		WatermarkID: watermarkID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if err := s.watermarkRepo.Create(log); err != nil {
		return nil, nil, err
	}

	return watermarkedData, log, nil
}
```
