1.上传阶段:
用户上传图片。
服务器在内存中对图片进行 AES 加密。
将 加密后 的数据存入数据库。数据库中永远只有密文。
2.水印处理/下载阶段:
控制器接收请求，比如 GET /image/:image_id/watermarked。
服务层通过 image_id 从数据库中取出 加密数据。
在内存中对数据进行 AES 解密，得到临时的明文图片数据。
在这份临时的明文数据上，执行 LSB 水印嵌入。
将加好 LSB 水印的图片（现在又是明文了）编码成 image/jpeg 或 image/png 格式。
将最终的图片二进制流直接返回给用户，不进行任何再次存储。

### 即时处理（On-the-fly）模型。

步骤一：设计加密图片模型和仓库

1.models/encrypted_image.go：模型层（实体定义）

作用：定义数据结构 + GORM 标签，供 GORM 使用。--与数据库中 encrypted_images 表对应。

不负责查询、不负责业务逻辑，仅代表结构体定义。

2.db/image_repository.go：数据库仓库层

封装数据库操作逻辑，如 CRUD（Create / Read / Update / Delete）。

只做数据库操作，不做密码学、也不处理 HTTP 请求。

3.services/crypto_service.go：业务逻辑层

作用：处理加密/解密业务逻辑，协调 Repository 和其他工具库。

聚合业务流程（比如：读取 → 解密 → 返回）。

调用 utils 实现加解密逻辑。

调用 repo 进行数据存取。


### page 2：go-cache 选择
缓存的是“最终结果”，而非“中间状态”。是一个黑盒。

位于业务逻辑的“最外层”： 
·缓存检查是控制器接收到请求后做的第一件事。
·如果缓存命中，整个复杂的业务逻辑（数据库查询、解密、加水印）都会被完全跳过——避免重复的昂贵计算。

与“不存储明文”原则的兼容性：
·数据库是永久性、结构化的存储，是我们的核心资产仓库。
而缓存是临时性、易失性的存储，它的目的是性能优化，我们预期其中的数据随时可能因为过期或内存压力而消失。
·风险可控：
生命周期短： 我们为缓存设置了较短的TTL（Time-To-Live，eg：5分钟）。
·非持久化： 使用go-cache，缓存存在于进程内存中。服务重启，缓存即清空，符合“用后即焚”的大原则。

### 基于时间分片 (Time Sharding) 的缓存策略

我们将时间戳“量化”或“取整”到一个固定的时间间隔。在同一个5分钟内，所有请求都使用相同的时间戳，从而生成相同的 LSB 水印和相同的缓存键，使得缓存能够命中。过了这个5分钟，时间戳更新，缓存自然失效，系统会生成新的带水印的图片并缓存起来。

**工作流程**:
1.  用户 `user-A` 请求 `image-123`。
2.  获取当前时间，并将其**向下取整**到最近的5分钟。例如，`10:03:45` -> `10:00:00`。
3.  生成缓存键，例如 `watermark:user-A:image-123:1678888800` (10:00:00 对应的时间戳)。
4.  **检查缓存**：
    *   **缓存未命中**:
        *   解密图片。
        *   使用 `user-A`, `image-123` 和 **`10:00:00` 的时间戳**生成 LSB 水印。
        *   嵌入水印。
        *   将这个**带 LSB 水印的明文图片**存入缓存，键为 `watermark:user-A:image-123:1678888800`，TTL 设置为5分钟。
        *   返回图片。
    *   **缓存命中**:
        *   直接从缓存中取出**带 LSB 水印的明文图片**并返回。

**依赖注入**
```
func NewWatermarkService(
	serverSecret string,
	cacheService CacheService,
	watermarkRepo db.WatermarkRepository,
	imageRepo db.EncryptedImageRepository,
	cryptoSvc CryptoService,
) WatermarkService {
	return &watermarkServiceImpl{
		// 下面3个是【内部创建】的
		idGenerator:   NewWatermarkIDGenerator(serverSecret),
		lsbProcessor:  NewLSBWatermarkProcessor("blue"),
		cacheKeyGen:   NewCacheKeyGenerator("watermark"),
		
		// 下面4个是【外部注入】的  对应上方的参数导入
		cacheService:  cacheService,
		watermarkRepo: watermarkRepo,
		imageRepo:     imageRepo,
		cryptoService: cryptoSvc,
	}
}
```

v1
```
func (s *watermarkServiceImpl) ProcessWatermarkedImage(userID, imageID string, imgData []byte) ([]byte, *models.WatermarkLog, error) {
	// 1. 检查缓存
	cacheKey := s.cacheKeyGen.WatermarkKey(userID, imageID)
	if cachedData, found := s.cacheService.Get(cacheKey); found {
		// 从数据库获取日志记录
		if log, err := s.watermarkRepo.GetByUserAndImage(userID, imageID); err == nil {
			return cachedData, log, nil
		}
	}

	// 2. 生成水印ID
	timestamp := time.Now().Unix()
	watermarkID, err := s.GenerateWatermarkID(userID, imageID, timestamp)
	if err != nil {
		return nil, nil, err
	}

	// 3. 解码图像
	img, format, err := image.Decode(bytes.NewReader(imgData))
	if err != nil {
		return nil, nil, err
	}

	// 4. 嵌入水印
	watermarkedImg, err := s.EmbedLSBWatermark(img, watermarkID)
	if err != nil {
		return nil, nil, err
	}

	// 5. 编码图像
	var buf bytes.Buffer
	switch format {
	case "jpeg":
		err = jpeg.Encode(&buf, watermarkedImg, &jpeg.Options{Quality: 95})
	case "png":
		err = png.Encode(&buf, watermarkedImg)
	default:
		err = errors.New("unsupported image format")
	}

	if err != nil {
		return nil, nil, err
	}

	watermarkedData := buf.Bytes()

	// 6. 写入缓存
	s.cacheService.Set(cacheKey, watermarkedData, time.Hour)

	// 7. 记录日志
	log := &models.WatermarkLog{
		UserID:      userID,
		ImageID:     imageID,
		WatermarkID: watermarkID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if err := s.watermarkRepo.Create(log); err != nil {
		return nil, nil, err
	}

	return watermarkedData, log, nil
}
```
输入： 业务ID (userID, imageID)，以及已经解密好的图片明文数据 (imgData []byte)。
输出： 处理后的图片字节流 ([]byte)、新创建的日志记录对象 (*models.WatermarkLog)、错误。
职责推断： 这个服务函数只关心核心的水印处理逻辑。它明确要求调用方（可能是另一个更高阶的服务，或是控制器）先把数据准备好（解密），它只负责在明文上“施工”。

 它将“获取并解密图片数据”这个前置步骤的责任推给了调用方。这使得该服务本身变得非常纯粹和独立。

v2
```
const cacheInterval = 5 * time.Minute // 定义缓存和时间分片的窗口期

func (s *watermarkServiceImpl) ProcessAndGetWatermarkedImage(userID, imageID string) ([]byte, string, error) {
	// 1. 获取量化后的时间戳
	now := time.Now()
	truncatedTime := TruncateTime(now, cacheInterval)
	timestamp := truncatedTime.Unix()

	// 2. 生成缓存键
	cacheKey := s.cacheKeyGen.WatermarkKey(userID, imageID, timestamp)

	// 3. 检查缓存
	if cachedData, found := s.cacheService.Get(cacheKey); found {
		fmt.Printf("Watermarked image HIT cache for key: %s\n", cacheKey)
		// 缓存命中，直接返回。同样需要查询一次元数据获取 contentType
		record, err := s.imageRepo.GetByID(imageID)
		if err != nil {
			return nil, "", err
		}
		return cachedData, record.ContentType, nil
	}

	fmt.Printf("Watermarked image MISS cache for key: %s\n", cacheKey)

	// --- 缓存未命中，执行完整流程 ---

	// 4. 从数据库获取并解密
	encryptedImage, err := s.imageRepo.GetByID(imageID)
	if err != nil {
		return nil, "", err
	}
	plaintextData, err := s.cryptoService.Decrypt(encryptedImage.EncryptedData)
	if err != nil {
		return nil, "", err
	}

	// 5. 使用【量化后的时间戳】生成 LSB 水印ID
	watermarkID, err := s.idGenerator.GenerateID(userID, imageID, timestamp)
	if err != nil {
		return nil, "", err
	}

	// 6. 解码图片
	img, format, err := image.Decode(bytes.NewReader(plaintextData))
	if err != nil {
		return nil, "", err
	}

	// 7. 嵌入 LSB 水印
	watermarkedImg, err := s.lsbProcessor.EmbedWatermark(img, watermarkID)
	if err != nil {
		return nil, "", err
	}

	// 8. 将处理后的图片编码为二进制流
	var buf bytes.Buffer
	// ... (编码逻辑不变) ...
	if err != nil {
		return nil, "", err
	}
	finalImageData := buf.Bytes()

	// 9. 将【带 LSB 水印的明文图片】存入缓存
	// TTL 设置为 cacheInterval，确保它在下一个时间窗口开始时失效
	s.cacheService.Set(cacheKey, finalImageData, cacheInterval)

	// 10. 记录日志
	log := &models.WatermarkLog{
		UserID:      userID,
		ImageID:     imageID,
		WatermarkID: watermarkID, // 使用的是包含量化时间戳的ID
	}
	go s.watermarkRepo.Create(log)

	return finalImageData, encryptedImage.ContentType, nil
}

// 将当前时间“取整”。--“时间量化”缓存策略
func TruncateTime(t time.Time, interval time.Duration) time.Time {
	return t.Truncate(interval)
}
```
输入： 业务ID (userID, imageID)。

输出： 最终的图片字节流 ([]byte)、图片的ContentType (string)、错误。

1.“胖服务”（Fat Service）设计。它把数据获取、解密、核心业务处理（加水印）、结果缓存、日志记录等所有步骤都封装在自己内部。--违反单一职责原则

2.缓存命中后的额外DB查询： 这是该方案的一个明显的设计缺陷。当缓存命中时，它为了获取ContentType，仍然需要再次查询数据库。这违背了缓存“完全绕过慢速I/O”的初衷。

每次生成唯一水印： 它使用time.Now()，意味着每次调用都会生成一个全新的水印ID，这会导致缓存命中率极低（除非在极短时间内重复请求）。

### 缓存设置：
要求能够缓存半个小时以便完成重复查询（go-cache只占用内存）
——将完整的结果（图像数据+日志）一起缓存，这样可以避免缓存命中时的数据库查询，真正发挥缓存的作用。
```
// 在 controllers 包中定义
type CachedImageResult struct {
	ImageBytes  []byte // 最终带 LSB 水印的图片字节流
	ContentType string // 图片的 MIME 类型, 如 "image/jpeg"
}
```
缓存命中时，能直接拿到 ContentType 来设置 HTTP 响应头，从而完全避免再次查询数据库。
```
// controllers/image_controller.go
	if val, found := ctrl.cache.Get(cacheKey); found {
		if cachedResult, ok := val.(CachedImageResult); ok {   
			c.Header("Content-Type", cachedResult.ContentType)
			c.Data(http.StatusOK, cachedResult.ContentType, cachedResult.ImageBytes) //返回 HTTP 响应，整个请求流程结束。
			return
		}
	}
```
用 interface{} 保存，具体类型不固定。使用ok：= val.(CachedImageResult) //类型断言

“安全断言” ，返回ok == true 或者 ok == false

### 更细化操作= 查日志验证+加水印+写日志 （均服务层分离）

弃用：
```
package services

import (
	"image"
	// "photo_service/models"
)

// WatermarkService 接口定义了服务层对外暴露的核心能力。
// 控制器将通过这个接口与服务层交互。
type WatermarkService interface {

	// 生成水印ID
	GenerateWatermarkID(userID, imageID string, timestamp int64) (string, error)

	// 嵌入LSB水印
	EmbedLSBWatermark(img image.Image, watermarkID string) (image.Image, error)

	// 提取LSB水印
	ExtractLSBWatermark(img image.Image, length int) (string, error)

	// 处理水印图片（完整流程）
	// ProcessWatermarkedImage(userID, imageID string, imgData []byte) ([]byte, *models.WatermarkLog, error)
	ProcessAndGetWatermarkedImage(userID, imageID string) (imageData []byte, contentType string, err error)

	// 验证水印
	VerifyWatermark(imgData []byte, expectedWatermarkID string) (bool, error)
}
```
