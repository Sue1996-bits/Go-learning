---

### **数字版权保护系统 - 不可见水印模块**


#### **1. 项目概述与目标**


接手一个数字图片处理与分发系统。本项目的核心目标是为我们的数字图片资产提供强有力的版权保护和泄露溯源能力。

当前系统已完成第一阶段的建设，具备了图片加密存储、解密、以及添加**可见文字水印**的基础功能。

你的核心任务是在此基础上，设计并实现一个**不可见数字水印**系统。该系统需要在用户请求图片时，动态地、无感知地在图片中嵌入一个与用户身份绑定的唯一标识，从而在图片被非法传播时，我们能够准确地追踪到泄露源头。

#### **2. 当前系统架构分析 (As-Is)**

根据项目当前的代码结构，系统现状如下：

- **技术栈:**
  - **后端框架:** Gin
  - **数据库:** SQLite (`photo.db`)
  - **ORM:** GORM
  - **核心依赖:** Go 标准库

- **目录结构解读:**
  - `main.go`: 程序入口，负责初始化路由、数据库等。
  - `go.mod` / `go.sum`: 项目依赖管理。
  - `photo.db`: SQLite 数据库文件。
  - **`controllers/`**: HTTP 请求处理器层。
    - `encrypt.go`, `decrypt.go`: 封装了独立的加解密接口逻辑。
  - **`db/`**: `db.go` 文件负责数据库的初始化和连接。
  - **`fonts/`**: `font.ttf` 字体文件，再次印证了当前水印为可见的文字水印。
  - **`models/`**: `FileRecord.go` 定义了与数据库表映射的 GORM 模型，用于记录文件元数据。
  - **`storage/uploads/`**: 原始（未加密）图片的物理存储位置。
  - **`utils/`**: `crypto.go` 提供了底层的加密/解密算法实现。

**总结：** 当前系统架构基础良好，但功能逻辑较为分散。可见水印功能已存在，为我们升级到不可见水印提供了很好的起点。

#### **3. 下一阶段需求与任务 (To-Be)**

需要完成以下核心功能的开发，将系统升级至具备不可见水印的能力。

**核心需求：**

1.  **实现不可见水印嵌入接口：**
    - 创建一个新的 API 接口：`GET /api/v1/images/:id/watermarked`。
    - 该接口应受身份认证保护，确保只有授权用户可以访问。
2.  **生成动态唯一水印ID：**
    - 水印信息必须对每个用户和每次请求都具有唯一性，以便精准溯源。
    - 需设计一个函数，结合**用户ID、图片ID、时间戳**和一个**服务器端密钥（Secret）**，通过 HMAC-SHA256 算法生成一个不可预测的水印ID。
3.  **实现水印嵌入算法：**
    - 这是任务的核心。你需要将生成的水印ID（二进制形式）嵌入到图片像素中。我们将分阶段实现，你的首要任务是完成第一阶段。
    - **第一阶段（MVP）：空间域 LSB 嵌入。** 将水印比特流嵌入到图片像素的蓝色（Blue）通道的最低有效位（LSB）。此方法实现快，对图像质量影响极小，但鲁棒性较弱。
4.  **建立水印追溯日志：**
    - 创建一个新的数据库模型 `WatermarkLog`。
    - 每当成功生成一张带水印的图片时，必须在该表中记录一条日志，包含 `UserID`, `ImageID`, `Watermark` (水印ID) 和 `Timestamp`。这是未来溯源的法律依据。
5.  **引入高性能缓存：**
    - 水印处理是计算密集型操作。为避免重复劳动，需引入缓存机制。
    - 使用**内存缓存**（如 `go-cache`）即可。
    - 缓存键（Key）应由 `userID` 和 `imageID` 组合而成。
    - 缓存值（Value）是已处理完成并编码好的图片字节流。

#### **4. 建议的架构重构与优化**

为使代码结构更清晰、更易于维护，建议在开发新功能的同时进行以下重构：

-   **引入 Service 层：**
    - 创建一个 `services/` 目录。
    - 将所有与水印相关的核心逻辑（ID生成、LSB嵌入等）封装在 `services/watermark_service.go` 中。这能让 Controller 层保持轻量，只负责请求的调度。
-   **整合 Controller：**
    - 将 `controllers/` 目录下的 `encrypt.go`, `decrypt.go`, `ImageHandler.go` 等与图片相关的逻辑，整合到一个统一的 `controllers/image_controller.go` 中。不同的功能可以通过不同的方法（如 `UploadImage`, `GetDecryptedImage`, `GetWatermarkedImage`）来暴露。

**建议的目标目录结构：**
```
/
├── controllers/
│   └── image_controller.go   // 统一的图片处理器
├── db/
│   └── db.go
├── models/
│   ├── file_record.go        // 已存在
│   └── watermark_log.go      // 【新增】水印日志模型
├── services/
│   └── watermark_service.go  // 【新增】水印核心服务
├── utils/
│   └── crypto.go
├── main.go
├── go.mod
└── photo.db
```

#### **5. 实施路线图 (Roadmap)**

请遵循以下分阶段交付计划：

**Phase 1: 实现核心功能 (MVP)**

1.  **数据库建模：** 在 `models/` 中创建 `watermark_log.go` 文件并定义 `WatermarkLog` 结构体。
2.  **服务层实现：** 在 `services/watermark_service.go` 中实现：
    - `GenerateWatermarkID()`: HMAC-SHA256 水印ID生成函数。
    - `EmbedLSBWatermark()`: LSB 空间域水印嵌入函数。
3.  **控制器与接口：** 在 `controllers/image_controller.go` 中创建 `GetWatermarkedImage` 方法，并实现完整的业务流程：
    - 身份认证 -> 查缓存 -> 读数据库 -> 解密 -> 解码 -> **调用水印服务** -> 编码 -> 写缓存 -> 写日志 -> 返回图片。
4.  **路由注册：** 在 `main.go` 中注册新接口 `GET /api/v1/images/:id/watermarked`。
5.  **编写测试：** 编写单元测试验证水印服务，并编写集成测试验证API接口。

**Phase 2: 鲁棒性增强 (后续迭代)**

当第一阶段稳定运行后，我们将计划引入**频域DCT水印**，以增强水印对抗压缩、裁剪等攻击的能力。届时会提供进一步的方案。

#### **6. 定义完成 (Definition of Done)**

**Phase 1 的完成标准：**

- [ ] 所有新代码均有清晰的注释和单元测试。
- [ ] `GET /api/v1/images/:id/watermarked` 接口按设计正常工作。
- [ ] 成功请求后，`watermark_logs` 表中会新增一条正确的记录。
- [ ] 缓存机制有效，对同一用户和图片的重复请求能命中缓存，快速返回。
- [ ] 系统能成功提取出嵌入的水印信息（可以为此编写一个离线验证脚本）。

---

